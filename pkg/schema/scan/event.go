package scan

import (
	"time"

	"github.com/censys/scan-takehome/pkg/schema"

	"github.com/transientvariable/anchor"
	"github.com/transientvariable/cadre/ecs"
	"github.com/transientvariable/cadre/validation"
	"github.com/transientvariable/cadre/validation/constraint"

	json "github.com/json-iterator/go"
)

var (
	_ schema.Event = (*Event)(nil)
)

// Event represents scan events generated by a scanning agent.
type Event struct {
	*ecs.Base
	Event   *ecs.Event   `json:"event,omitempty"`
	Network *ecs.Network `json:"network,omitempty"`
	Source  *ecs.Source  `json:"source,omitempty"`

	eventType string
}

// NewEvent creates a new scan Event using the provided event type and scan data.
func NewEvent(eventType string, metadata *Metadata) (*Event, error) {
	// Timestamp of when the scan was performed/generated from the source.
	// This will be set as the Event.Timestamp.
	ts := metadata.Timestamp.UTC()

	// Timestamp to indicate when an event was created and is distinct from the Event.Timestamp.
	created := time.Now().UTC()

	se := &Event{
		Base: &ecs.Base{
			Timestamp: &ts,
			Message:   metadata.Message,
		},
		Event: &ecs.Event{
			ID:       metadata.ID,
			Created:  &created,
			Kind:     ecs.EventKindEvent,
			Category: []string{ecs.EventCategoryHost},
			Type:     []string{eventType},
		},
		Network: &ecs.Network{
			Protocol: metadata.Network.Protocol,
		},
		Source: &ecs.Source{
			IP:   metadata.Source.IP,
			Port: metadata.Source.Port,
		},
		eventType: eventType,
	}

	if result := se.validate(); !result.IsValid() {
		return nil, result
	}
	return se, nil
}

// ID returns unique identifier for the scan Event.
func (e *Event) ID() string {
	return e.Event.ID
}

// Name returns the name for the Event.
func (e *Event) Name() string {
	return "scan-event"
}

// Metadata returns that metadata for the scan Event.
func (e *Event) Metadata() map[string]any {

	return nil
}

// Timestamp returns the date/time when the scan Event originated.
func (e *Event) Timestamp() *time.Time {
	return e.Base.Timestamp
}

// ToMap converts the Event fields and their values to a map.
func (e *Event) ToMap() (map[string]any, error) {
	var m map[string]any
	if err := json.Unmarshal(anchor.ToJSON(e), &m); err != nil {
		return nil, err
	}
	return m, nil
}

// Type returns the event type for the scan Event.
func (e *Event) Type() string {
	return e.eventType
}

// String returns a string representation of the Event.
func (e *Event) String() string {
	return string(anchor.ToJSONFormatted(map[string]any{
		"scan_event": map[string]any{
			"id":   e.ID(),
			"type": e.Type(),
		},
	}))
}

// validate performs validation of a scan Event.
func (e *Event) validate() *validation.Result {
	var validators []validation.Validator
	validators = append(validators, constraint.NotBlank{
		Name:    "eventType",
		Field:   e.eventType,
		Message: "scan_event: event type is required",
	})

	validators = append(validators, constraint.NotBlank{
		Name:    "eventMessage",
		Field:   e.Message,
		Message: "scan_event: event message is required",
	})

	if e.eventType == ecs.EventTypeChange {
		validators = append(validators, constraint.NotBlank{
			Name:    "eventID",
			Field:   e.Event.ID,
			Message: "scan_event: ID is required",
		})
	}
	return validation.Validate(validators...)
}
