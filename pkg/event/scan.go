package event

import (
	"encoding/base64"
	"fmt"
	"strings"
	"time"

	"github.com/censys/scan-takehome/pkg/scanning"

	"github.com/transientvariable/anchor"
	"github.com/transientvariable/cadre/ecs"
	"github.com/transientvariable/cadre/validation"
	"github.com/transientvariable/cadre/validation/constraint"
)

var (
	_ Event = (*ScanEvent)(nil)
)

// ScanEvent represents scan events generated by a scanning agent.
type ScanEvent struct {
	*ecs.Base
	Event   *ecs.Event   `json:"event,omitempty"`
	Host    *ecs.Host    `json:"host,omitempty"`
	Network *ecs.Network `json:"network,omitempty"`
	Service *ecs.Service `json:"service,omitempty"`

	eventType string
}

// NewScanEvent creates a new Event using the provided event type and scan data.
func NewScanEvent(eventType string, scan *scanning.Scan) (*ScanEvent, error) {
	// Timestamp of when the scan was performed/generated from the source.
	// This will be set as the scanEvent.Timestamp.
	ts := time.Unix(scan.Timestamp, 0)

	// Timestamp to indicate when an event was created and is distinct from the event.Timestamp.
	created := time.Now().UTC()

	se := &ScanEvent{
		Base: &ecs.Base{
			Timestamp: &ts,
		},
		Event: &ecs.Event{
			Created:  &created,
			Kind:     ecs.EventKindEvent,
			Category: []string{ecs.EventCategoryHost},
			Type:     []string{eventType},
		},
		Host: &ecs.Host{
			IP: scan.Ip,
		},
		Network: &ecs.Network{
			Protocol: scan.Service,
		},
		eventType: eventType,
	}

	// Decode the response data for the event, event.Message should contain the decoded response.
	if err := decodeResponse(scan, se); err != nil {
		return nil, fmt.Errorf("scan_event: could not decode response for scan %s: %w", scan.Ip, err)
	}

	if result := se.validate(); !result.IsValid() {
		return nil, result
	}
	return se, nil
}

// ID returns unique identifier for the ScanEvent.
func (e *ScanEvent) ID() string {
	return e.Event.ID
}

func (e *ScanEvent) Payload() any {
	return nil
}

// Type returns the event type for the ScanEvent.
func (e *ScanEvent) Type() string {
	return e.eventType
}

// String returns a string representation of the ScanEvent.
func (e *ScanEvent) String() string {
	em := make(map[string]any)
	em["scan_event"] = e
	em["id"] = e.ID()
	em["type"] = e.Type()
	return string(anchor.ToJSONFormatted(em))
}

// validate performs validation of a ScanEvent.
func (e *ScanEvent) validate() *validation.Result {
	var validators []validation.Validator
	validators = append(validators, constraint.NotBlank{
		Name:    "eventType",
		Field:   e.eventType,
		Message: "scan_event: event type is required",
	})

	validators = append(validators, constraint.NotBlank{
		Name:    "eventMessage",
		Field:   e.Message,
		Message: "scan_event: event message is required",
	})

	if e.eventType == ecs.EventTypeChange {
		validators = append(validators, constraint.NotBlank{
			Name:    "eventID",
			Field:   e.Event.ID,
			Message: "scan_event: ID is required",
		})
	}
	return validation.Validate(validators...)
}

func decodeResponse(scan *scanning.Scan, event *ScanEvent) error {
	switch scan.DataVersion {
	case scanning.V1:
		d := scan.Data.([]byte)
		event.Network.Bytes = int64(len(d))
		event.Message = strings.TrimSpace(string(d))
	case scanning.V2:
		d := scan.Data.(string)
		event.Network.Bytes = int64(len([]byte(d)))
		event.Message = strings.TrimSpace(d)
	default:
		return fmt.Errorf("%w: %d", ErrDataVersionUnsupported, scan.DataVersion)
	}

	if m, err := base64.StdEncoding.DecodeString(event.Message); err == nil {
		event.Message = string(m)
	}
	return nil
}
